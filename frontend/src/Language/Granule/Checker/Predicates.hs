{-# LANGUAGE GADTs #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE DeriveGeneric #-}

{-# options_ghc -Wno-incomplete-record-updates #-}

module Language.Granule.Checker.Predicates where

{-

This module provides the representation of theorems (predicates)
inside the type checker.

-}

import Control.Monad.Trans.State.Strict
import Data.List (intercalate, (\\))
import GHC.Generics (Generic)

import Language.Granule.Context

import Language.Granule.Syntax.Helpers
import Language.Granule.Syntax.Identifiers
import Language.Granule.Syntax.FirstParameter
import Language.Granule.Syntax.Pretty
import Language.Granule.Syntax.Span
import Language.Granule.Syntax.Type

data Quantifier =
    -- | Universally quantification, e.g. polymorphic
    ForallQ

    -- | Instantiations of universally quantified variables
    | InstanceQ

    -- | Univeral, but bound in a dependent pattern match
    | BoundQ
  deriving (Show, Eq)

instance Pretty Quantifier where
  pretty ForallQ   = "∀"
  pretty InstanceQ = "∃"
  pretty BoundQ    = "pi"

stripQuantifiers :: Ctxt (a, Quantifier) -> Ctxt a
stripQuantifiers = map (\(var, (k, _)) -> (var, k))


-- Represent constraints generated by the type checking algorithm
data Constraint =
  -- Coeffect resource algebra constraints
    Eq  Span Coeffect Coeffect Type
  | Neq Span Coeffect Coeffect Type
  | ApproximatedBy Span Coeffect Coeffect Type

  --
  | Lub Span Coeffect Coeffect Coeffect Type

  -- NonZeroPromotableTo s x c means that:
  --   exists x . (x != 0) and x * 1 = c
  -- This is used to check constraints related to definite unification
  -- which incurrs a consumption effect
  | NonZeroPromotableTo Span Id Coeffect Type

  -- Used for user-predicates, and also effect types
  | Lt Span Coeffect Coeffect -- Must be Nat kinded
  | Gt Span Coeffect Coeffect -- Must be Nat kinded
  | LtEq Span Coeffect Coeffect -- Must be Nat kinded
  | GtEq Span Coeffect Coeffect -- Must be Nat kinded

  deriving (Show, Eq, Generic)

instance FirstParameter Constraint Span

normaliseConstraint :: Constraint -> Constraint
normaliseConstraint (Eq s c1 c2 t)   = Eq s (normalise c1) (normalise c2) t
normaliseConstraint (Neq s c1 c2 t)  = Neq s (normalise c1) (normalise c2) t
normaliseConstraint (Lub s c1 c2 c3 t) = Lub s (normalise c1) (normalise c2) (normalise c3) t
normaliseConstraint (ApproximatedBy s c1 c2 t) = ApproximatedBy s (normalise c1) (normalise c2) t
normaliseConstraint (NonZeroPromotableTo s x c t) = NonZeroPromotableTo s x (normalise c) t
normaliseConstraint (Lt s c1 c2) = Lt s (normalise c1) (normalise c2)
normaliseConstraint (Gt s c1 c2) = Gt s (normalise c1) (normalise c2)
normaliseConstraint (LtEq s c1 c2) = LtEq s (normalise c1) (normalise c2)
normaliseConstraint (GtEq s c1 c2) = GtEq s (normalise c1) (normalise c2)

instance Monad m => Freshenable m Constraint where
  freshen (Eq s' c1 c2 k) = do
    c1 <- freshen c1
    c2 <- freshen c2
    return $ Eq s' c1 c2 k

  freshen (Neq s' c1 c2 k) = do
    c1 <- freshen c1
    c2 <- freshen c2
    return $ Neq s' c1 c2 k

  freshen (ApproximatedBy s' c1 c2 t) = do
    c1 <- freshen c1
    c2 <- freshen c2
    return $ ApproximatedBy s' c1 c2 t

  freshen (Lub s' c1 c2 c3 t) = do
    c1 <- freshen c1
    c2 <- freshen c2
    c3 <- freshen c3
    return $ Lub s' c1 c2 c3 t

  freshen (NonZeroPromotableTo s i c t) = do
    c <- freshen c
    t <- freshen t
    return $ NonZeroPromotableTo s i c t

  freshen (Lt s c1 c2) = do
    c1 <- freshen c1
    c2 <- freshen c2
    return $ Lt s c1 c2

  freshen (Gt s c1 c2) = do
    c1 <- freshen c1
    c2 <- freshen c2
    return $ Gt s c1 c2

  freshen (LtEq s c1 c2) = LtEq s <$> freshen c1 <*> freshen c2
  freshen (GtEq s c1 c2) = GtEq s <$> freshen c1 <*> freshen c2

-- Used to negate constraints
newtype Neg a = Neg a
  deriving (Eq, Show)

instance Pretty (Neg Constraint) where
    pretty (Neg (Neq _ c1 c2 _)) =
      "Trying to prove that " <> pretty c1 <> " == " <> pretty c2

    pretty (Neg (Eq _ c1 c2 _)) =
      "Actual grade or index `" <> pretty c1 <>
      "` is not equal to specified grade or index `" <> pretty c2 <> "`"

    pretty (Neg (ApproximatedBy _ c1 c2 (TyCon k))) | internalName k == "Level" =
      pretty c2 <> " value cannot be moved to level " <> pretty c1

    pretty (Neg (ApproximatedBy _ c1 c2 k)) =
      case k of
        TyCon (internalName -> "Nat") ->
          "Expected " <> pretty c2 <> " uses, but instead there are " <> pretty c1 <> " actual uses."
        _ -> pretty c1 <> " is not approximatable by " <> pretty c2 <> " for type " <> pretty k

    pretty (Neg p@Lub{}) = 
      "Trying to prove negation of statement: " ++ pretty p

    pretty (Neg (NonZeroPromotableTo _ _ c _)) = "TODO"

    pretty (Neg (Lt _ c1 c2)) =
      "Trying to prove false statement: (" <> pretty c1 <> " < " <> pretty c2 <> ")"

    pretty (Neg (Gt _ c1 c2)) =
      "Trying to prove false statement: (" <> pretty c1 <> " > " <> pretty c2 <> ")"

    pretty (Neg (LtEq _ c1 c2)) =
      "Trying to prove false statement: (" <> pretty c1 <> " ≤ " <> pretty c2 <> ")"

    pretty (Neg (GtEq _ c1 c2)) =
      "Trying to prove false statement: (" <> pretty c1 <> " ≥ " <> pretty c2 <> ")"

instance Pretty [Constraint] where
    pretty constr =
      "---\n" <> (intercalate "\n" . map pretty $ constr)

instance Pretty Constraint where
    pretty (Eq _ c1 c2 _) =
      "(" <> pretty c1 <> " = " <> pretty c2 <> ")" -- @" <> show s

    pretty (Neq _ c1 c2 _) =
        "(" <> pretty c1 <> " ≠ " <> pretty c2 <> ")" -- @" <> show s

    pretty (ApproximatedBy _ c1 c2 k) =
      case k of
        -- Nat is discrete
        TyCon (internalName -> "Nat") -> "(" <> pretty c1 <> " = " <> pretty c2 <> ")"
        _ -> "(" <> pretty c1 <> " ≤ " <> pretty c2 <> ")" -- <> " @ " <> pretty k

    pretty (Lub _ c1 c2 c3 _) =
      "(" <> pretty c1 <> " ⊔ " <> pretty c2 <> " = " <> pretty c3 <> ")"

    pretty (Lt _ c1 c2) =
      "(" <> pretty c1 <> " < " <> pretty c2 <> ")"

    pretty (Gt _ c1 c2) =
      "(" <> pretty c1 <> " > " <> pretty c2 <> ")"

    pretty (LtEq _ c1 c2) =
      "(" <> pretty c1 <> " ≤ " <> pretty c2 <> ")"

    pretty (GtEq _ c1 c2) =
      "(" <> pretty c1 <> " ≥ " <> pretty c2 <> ")"

    pretty (NonZeroPromotableTo _ _ c _) = "TODO"


varsConstraint :: Constraint -> [Id]
varsConstraint (Eq _ c1 c2 _) = freeVars c1 <> freeVars c2
varsConstraint (Neq _ c1 c2 _) = freeVars c1 <> freeVars c2
varsConstraint (Lub _ c1 c2 c3 _) = freeVars c1 <> freeVars c2 <> freeVars c3
varsConstraint (ApproximatedBy _ c1 c2 _) = freeVars c1 <> freeVars c2
varsConstraint (NonZeroPromotableTo _ _ c _) = freeVars c
varsConstraint (Lt _ c1 c2) = freeVars c1 <> freeVars c2
varsConstraint (Gt _ c1 c2) = freeVars c1 <> freeVars c2
varsConstraint (LtEq _ c1 c2) = freeVars c1 <> freeVars c2
varsConstraint (GtEq _ c1 c2) = freeVars c1 <> freeVars c2


-- Represents a predicate generated by the type checking algorithm
data Pred where
    Conj :: [Pred] -> Pred
    Disj :: [Pred] -> Pred
    Impl :: Pred -> Pred -> Pred
    Con  :: Constraint -> Pred
    NegPred  :: Pred -> Pred
    Exists :: Id -> Kind -> Pred -> Pred
    Forall :: Id -> Kind -> Pred -> Pred

-- Predicate zipper
data PredPath =
    Top
  | ConjLeft       { parent :: PredPath, pinQuantifiers :: Bool }
  | ConjRight      { conjLeft :: Pred, parent :: PredPath, pinQuantifiers :: Bool }
  | DisjLeft       { parent :: PredPath, pinQuantifiers :: Bool }
  | DisjRight      { disjLeft :: Pred, parent :: PredPath, pinQuantifiers :: Bool }
  | ImplPremise    { parent :: PredPath , pinQuantifiers :: Bool}
  | ImplConclusion { implPremise :: Pred, parent :: PredPath, pinQuantifiers :: Bool }
  | ExistsBody     { existsId :: Id, existsKind :: Kind, parent :: PredPath }
  | ForallBody     { forallId :: Id, forallKind :: Kind, parent :: PredPath }
  deriving (Show, Eq)

pinHere :: PredPath -> Bool
pinHere Top          = True
pinHere ExistsBody{} = True
pinHere ForallBody{} = True
pinHere p = pinQuantifiers p

-- | moveRight traverses 'up' a predicate zipper until we reach an `open` two-node which
-- | is waiting to be closed with a left-subtree, at which point it returns the remaining
-- | path with the left subtree (so that a two-node with the left filled in can be made)
moveRight :: PredPath -> (Pred, PredPath)
moveRight path = (predTrans (Conj []), path')
  where
    (predTrans, path') = moveRight' path

    -- Stop unwinding at an 'open' node
    moveRight' (ImplPremise path _) = (id, path)
    moveRight' (ConjLeft path _)    = (id, path)
    moveRight' (DisjLeft path _)    = (id, path)

    -- Unwind the rest
    moveRight' Top = (id, Top)

    moveRight' (ConjRight left path _) =
      let (p, path') = moveRight' path
      in  (p . (\right -> Conj [left, right]), path')

    moveRight' (DisjRight left path _) =
      let (p, path') = moveRight' path
      in  (p . (\right -> Disj [left, right]), path')

    moveRight' (ImplConclusion prem path _) =
      let (p, path') = moveRight' path
      in  (p . (\concl -> Impl prem concl), path')

    moveRight' (ForallBody id kind path) =
      let (p, path') = moveRight' path
      in  (p . (\body -> Forall id kind body), path')

    moveRight' (ExistsBody id kind path) =
      let (p, path') = moveRight' path
      in  (p . (\body -> Exists id kind body), path')

pathToPredicate :: PredPath -> Pred
pathToPredicate path = predTrans (Conj [])
  where
   predTrans = pathToPredicate' path

    -- Stop unwinding at an 'open' node
   pathToPredicate' (ImplPremise path _) =
     error $ "Internal bug. Path contains an open implication. Path was: " ++ show path
   pathToPredicate' (ConjLeft path _) =
     error $ "Internal bug. Path contains an open conjunction. Path was: " ++ show path
   pathToPredicate' (DisjLeft path _) =
     error $ "Internal bug. Path contains an open disjunction. Path was: " ++ show path

    -- Unwind the rest
   pathToPredicate' Top = id

   pathToPredicate' (ConjRight left path _) =
      (pathToPredicate' path) . (\right -> Conj [left, right])

   pathToPredicate' (DisjRight left path _) =
      (pathToPredicate' path) . (\right -> Disj [left, right])

   pathToPredicate' (ImplConclusion prem path _) =
      (pathToPredicate' path) . (\concl -> Impl prem concl)

   pathToPredicate' (ForallBody id kind path) =
      (pathToPredicate' path) . (\body -> Forall id kind body)

   pathToPredicate' (ExistsBody id kind path) =
      (pathToPredicate' path) . (\body -> Exists id kind body)

insertPin :: PredPath -> PredPath
insertPin (ConjLeft path _) = ConjLeft path True
insertPin (ConjRight pred path _) = ConjRight pred path True
insertPin (DisjLeft path _) = DisjLeft path True
insertPin (DisjRight pred path _) = DisjRight pred path True
insertPin (ImplPremise path _) = ImplPremise path True
insertPin (ImplConclusion pred path _) = ImplConclusion pred path True
insertPin p = p

existentialAtPin :: Id -> Kind -> PredPath -> PredPath
existentialAtPin id k Top =  ExistsBody id k Top
existentialAtPin id k p =
  if pinHere p
    then ExistsBody id k p
    else p { parent = existentialAtPin id k (parent p) }

universalAtPin :: Id -> Kind -> PredPath -> PredPath
universalAtPin id k Top =  ForallBody id k Top
universalAtPin id k p =
  if pinHere p
    then ForallBody id k p
    else p { parent = universalAtPin id k (parent p) }

mkUniversals :: Ctxt Kind -> Pred -> Pred
mkUniversals [] p = p
mkUniversals ((v, k) : ctxt) p =
  Forall v k (mkUniversals ctxt p)

instance Term Pred where
  freeVars (Conj ps) = concatMap freeVars ps
  freeVars (Disj ps) = concatMap freeVars ps
  freeVars (Impl p1 p2) = freeVars p1 <> freeVars p2
  freeVars (Con c) = varsConstraint c
  freeVars (NegPred p) = freeVars p
  freeVars (Exists x _ p) = freeVars p \\ [x]
  freeVars (Forall x _ p) = freeVars p \\ [x]

boundVars :: Pred -> [Id]
boundVars (Conj ps)    = concatMap boundVars ps
boundVars (Disj ps)    = concatMap boundVars ps
boundVars (Impl p1 p2) = boundVars p1 ++ boundVars p2
boundVars (NegPred p)  = boundVars p
boundVars (Exists x _ p) = x : boundVars p
boundVars (Forall x _ p) = x : boundVars p
boundVars (Con _) = []

instance (Monad m, MonadFail m) => Freshenable m Pred where
  freshen (Conj ps) = do
    ps' <- mapM freshen ps
    return $ Conj ps'

  freshen (Disj ps) = do
    ps' <- mapM freshen ps
    return $ Disj ps'

  freshen (NegPred p) = do
    p' <- freshen p
    return $ NegPred p'

  freshen (Exists v k p) = do
    st <- get

    -- Create a new binding name for v
    let v' = internalName v <> "-e" <> show (counter st)

    -- Updated freshener state
    put (st { tyMap = (internalName v, v') : tyMap st
          , counter = counter st + 1 })

    -- Freshen the rest of the predicate
    p' <- freshen p
    -- Freshening now out of scope
    removeFreshenings [Id (internalName v) v']

    return $ Exists (Id (internalName v) v') k p'

  freshen (Forall v k p) = do
    st <- get

    -- Create a new binding name for v
    let v' = internalName v <> "-e" <> show (counter st)

    -- Updated freshener state
    put (st { tyMap = (internalName v, v') : tyMap st
          , counter = counter st + 1 })

    -- Freshen the rest of the predicate
    p' <- freshen p
    -- Freshening now out of scope
    removeFreshenings [Id (internalName v) v']

    return $ Forall (Id (internalName v) v') k p'

  freshen (Impl p1 p2) = do
    p1' <- freshen p1
    p2' <- freshen p2
    return $ Impl p1' p2'

  freshen (Con cons) = do
    cons' <- freshen cons
    return $ Con cons'

deriving instance Show Pred
deriving instance Eq Pred

-- Fold operation on a predicate
predFold ::
     ([a] -> a)
  -> ([a] -> a)
  -> (a -> a -> a)
  -> (Constraint -> a)
  -> (a -> a)
  -> (Id -> Kind -> a -> a)
  -> (Id -> Kind -> a -> a)
  -> Pred
  -> a
predFold c d i a n e f (Conj ps)      = c (map (predFold c d i a n e f) ps)
predFold c d i a n e f (Disj ps)      = d (map (predFold c d i a n e f) ps)
predFold c d i a n e f (Impl p p')    = i (predFold c d i a n e f p) (predFold c d i a n e f p')
predFold _ _ _ a _  _ _ (Con cons)    = a cons
predFold c d i a n e f (NegPred p)    = n (predFold c d i a n e f p)
predFold c d i a n e f (Exists x t p) = e x t (predFold c d i a n e f p)
predFold c d i a n e f (Forall x t p) = f x t (predFold c d i a n e f p)

-- Fold operation on a predicate (monadic)
predFoldM :: Monad m =>
     ([a] -> m a)
  -> ([a] -> m a)
  -> (a -> a -> m a)
  -> (Constraint -> m a)
  -> (a -> m a)
  -> (Id -> Kind -> a -> m a)
  -> (Id -> Kind -> a -> m a)
  -> Pred
  -> m a
predFoldM c d i a n e f (Conj ps)   = do
  ps <- mapM (predFoldM c d i a n e f) ps
  c ps

predFoldM c d i a n e f (Disj ps)   = do
  ps <- mapM (predFoldM c d i a n e f) ps
  d ps

predFoldM c d i a n e f (Impl p p') = do
  p  <- predFoldM c d i a n e f p
  p' <- predFoldM c d i a n e f p'
  i p p'

predFoldM _ _ _ a _ _ _ (Con cons)  =
  a cons

predFoldM c d i a n e f (NegPred p) =
  predFoldM c d i a n e f p >>= n

predFoldM c d i a n e f (Exists x t p) =
  predFoldM c d i a n e f p >>= e x t

predFoldM c d i a n e f (Forall x t p) =
  predFoldM c d i a n e f p >>= f x t

instance Pretty [Pred] where
  pretty ps =
    "Size = " <> show (length ps) <> "\n" <>
    (intercalate "\n" (map (\p -> " - " <> pretty p) ps))

instance Pretty Pred where
  pretty =
    predFold
     (\ps -> if null ps then "T" else intercalate " ∧ " ps)
     (\ps -> if null ps then "F" else intercalate " ∨ " ps)
     (\p q -> "(" <> p <> " -> " <> q <> ")")
     pretty
     (\p -> "¬(" <> p <> ")")
     (\x t p -> "∃ " <> pretty x <> " : " <> pretty t <> " . (" <> p <> ")")
     (\x t p -> "∀ " <> pretty x <> " : " <> pretty t <> " . (" <> p <> ")")

-- | Whether the predicate is empty, i.e. contains no constraints
isTrivial :: Pred -> Bool
isTrivial = predFold and or (\lhs rhs -> rhs) (const False) id (\_ _ p -> p) (\_ _ p -> p)

-- Transform universal quantifiers to existentials for the given list of
-- identifiers. This is used for looking at whether a universal theorem
-- can ever be satisfied (e.g., for checking whether dependent-pattern match
-- cases are possible)
universalsAsExistentials :: [Id] -> Pred -> Pred
universalsAsExistentials vars =
    predFold Conj Disj Impl Con NegPred Exists forallCase
  where
    forallCase var kind p =
      if var `elem` vars then Exists var kind p else Forall var kind p